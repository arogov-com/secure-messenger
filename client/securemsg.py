#!/bin/env python
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'smsg.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMessageBox
import socket
import hashlib
import base64
import json
import time
from ecies.utils import generate_eth_key
from ecies import encrypt, decrypt
import threading
import queue
import logging

KEY_PATH = 'user1.key'


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(591, 501)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
        MainWindow.setSizePolicy(sizePolicy)
        MainWindow.setTabShape(QtWidgets.QTabWidget.Rounded)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.tabWidget = QtWidgets.QTabWidget(self.centralwidget)
        self.tabWidget.setGeometry(QtCore.QRect(0, 0, 600, 500))
        self.tabWidget.setTabShape(QtWidgets.QTabWidget.Rounded)
        self.tabWidget.setObjectName("tabWidget")
        self.tab_conn = QtWidgets.QWidget()
        self.tab_conn.setObjectName("tab_conn")
        self.lineEdit_server = QtWidgets.QLineEdit(self.tab_conn)
        self.lineEdit_server.setGeometry(QtCore.QRect(10, 40, 113, 25))
        self.lineEdit_server.setObjectName("lineEdit_server")
        self.lineEdit_user = QtWidgets.QLineEdit(self.tab_conn)
        self.lineEdit_user.setGeometry(QtCore.QRect(150, 40, 113, 25))
        self.lineEdit_user.setObjectName("lineEdit_user")
        self.lineEdit_pass = QtWidgets.QLineEdit(self.tab_conn)
        self.lineEdit_pass.setGeometry(QtCore.QRect(290, 40, 113, 25))
        self.lineEdit_pass.setObjectName("lineEdit_pass")
        self.label_server = QtWidgets.QLabel(self.tab_conn)
        self.label_server.setGeometry(QtCore.QRect(10, 20, 62, 17))
        self.label_server.setObjectName("label_server")
        self.label_user = QtWidgets.QLabel(self.tab_conn)
        self.label_user.setGeometry(QtCore.QRect(150, 20, 111, 17))
        self.label_user.setScaledContents(False)
        self.label_user.setObjectName("label_user")
        self.label_pass = QtWidgets.QLabel(self.tab_conn)
        self.label_pass.setGeometry(QtCore.QRect(290, 20, 111, 17))
        self.label_pass.setObjectName("label_pass")
        self.btn_signin = QtWidgets.QPushButton(self.tab_conn)
        self.btn_signin.setGeometry(QtCore.QRect(430, 40, 51, 25))
        self.btn_signin.setObjectName("btn_signin")
        self.btn_register = QtWidgets.QPushButton(self.tab_conn)
        self.btn_register.setGeometry(QtCore.QRect(490, 40, 61, 25))
        self.btn_register.setObjectName("btn_register")
        self.tabWidget.addTab(self.tab_conn, "")
        self.tab_msg = QtWidgets.QWidget()
        self.tab_msg.setToolTipDuration(-1)
        self.tab_msg.setObjectName("tab_msg")
        self.list_Widget = QtWidgets.QListWidget(self.tab_msg)
        self.list_Widget.setGeometry(QtCore.QRect(129, 0, 461, 450))
        self.list_Widget.setObjectName("list_Widget")
        self.btn_send = QtWidgets.QPushButton(self.tab_msg)
        self.btn_send.setGeometry(QtCore.QRect(560, 450, 31, 21))
        self.btn_send.setObjectName("btn_send")
        self.line_msg = QtWidgets.QLineEdit(self.tab_msg)
        self.line_msg.setGeometry(QtCore.QRect(130, 450, 431, 25))
        self.line_msg.setObjectName("line_msg")
        self.list_users = QtWidgets.QListWidget(self.tab_msg)
        self.list_users.setGeometry(QtCore.QRect(0, 0, 130, 474))
        self.list_users.setObjectName("list_users")
        self.tabWidget.addTab(self.tab_msg, "")
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.current_chat_user = ''
        self.client = client()
        self.client.load_keys(KEY_PATH, 'srv.key')

        self.btn_signin.clicked.connect(self.handler_connect)
        self.btn_register.clicked.connect(self.handler_register)
        self.btn_send.clicked.connect(self.handler_send)
        self.list_users.itemClicked.connect(self.handler_list_users_click)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Secure chat"))
        self.lineEdit_server.setText(_translate("MainWindow", "localhost:9000"))
        self.label_server.setText(_translate("MainWindow", "Server"))
        self.label_user.setText(_translate("MainWindow", "User name"))
        self.label_pass.setText(_translate("MainWindow", "Password"))
        self.btn_signin.setText(_translate("MainWindow", "Sign In"))
        self.btn_register.setText(_translate("MainWindow", "Register"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_conn), _translate("MainWindow", "Connection"))
        self.btn_send.setText(_translate("MainWindow", ">>"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_msg), _translate("MainWindow", "Message"))

    def handler_list_users_click(self, item):
        if not self.client.users_list.get(item.text()):
            key = self.client.req_key(item.text())
            if not key:
                self.list_Widget.addItem(f'Can\'t get key for user {item.text()}')
                return

            self.client.users_list[item.text()] = key

        item.setForeground(QtGui.QColor('black'))
        self.current_chat_user = item.text()
        self.list_Widget.clear()
        self.list_Widget.addItem(f'Chat with {self.current_chat_user} has started')
        if self.client.messages.get(self.current_chat_user):
            for i in self.client.messages[self.current_chat_user]:
                self.list_Widget.addItem(f"[{time.strftime('%H:%M:%S', time.localtime(i['time']))} {i['sender'] if i['sender'] != self.user else 'Me'}] {i['msg']}")

    def handler_connect(self):
        if not self.client.connected:
            error = False
            if self.lineEdit_server.text() == '':
                self.lineEdit_server.setStyleSheet('background-color: red')
                error = True
            else:
                self.lineEdit_server.setStyleSheet('background-color: white')

            if self.lineEdit_user.text() == '':
                self.lineEdit_user.setStyleSheet('background-color: red')
                error = True
            else:
                self.lineEdit_user.setStyleSheet('background-color: white')

            if self.lineEdit_pass.text() == '':
                self.lineEdit_pass.setStyleSheet('background-color: red')
                error = True
            else:
                self.lineEdit_pass.setStyleSheet('background-color: white')

            if error:
                return

            server_port = self.lineEdit_server.text().split(':')

            if len(server_port) == 1:
                self.server = server_port
            elif len(server_port) == 2:
                try:
                    self.port = int(server_port[1])
                except ValueError:
                    return
                else:
                    self.server = server_port[0]

            self.user = self.lineEdit_user.text()
            self.password = self.lineEdit_pass.text()

            self.event = threading.Event()

            if self.client.connect(self.user, self.password, self.event, self.server, self.port):
                self.list_Widget.addItem('Connected!')
            else:
                self.list_Widget.addItem('Failed to connect')
                return

            self.client.load_users()

            self.list_users.clear()
            for k, v in self.client.users_list.items():
                if k != self.user:
                    self.list_users.addItem(k)

            self.thread = threading.Thread(target=self.thread_recv, daemon=True)
            self.thread.start()

            self.btn_signin.setText(QtCore.QCoreApplication.translate("MainWindow", "Log out"))
            self.tabWidget.setCurrentIndex(1)
        else:
            self.client.disconnect()
            self.btn_signin.setText(QtCore.QCoreApplication.translate("MainWindow", "Log in"))

    def handler_register(self):
        if self.lineEdit_user.text() == '' or self.lineEdit_pass.text() == '' or self.lineEdit_server.text() == '':
            error = QMessageBox()
            error.setWindowTitle('Error')
            error.setText('Please, fill all fields')
            error.setIcon(QMessageBox.Warning)
            error.setStandardButtons(QMessageBox.Ok)
            error.exec_()
            return False

        port = 9000
        server = 'localhost'

        server_port = self.lineEdit_server.text().split(':')

        if len(server_port) == 1:
            server = server_port[0]
        elif len(server_port) == 2:
            try:
                server = server_port[0]
                port = int(server_port[1])
            except ValueError:
                return False
            else:
                server = server_port[0]

        if self.client.register_user(self.lineEdit_user.text(), self.lineEdit_pass.text(), server, port):
            self.list_Widget.addItem('User registred')
        else:
            self.list_Widget.addItem('Failed to register user')
            error = QMessageBox()
            error.setWindowTitle('Error')
            error.setText('Failed to register user')
            error.setIcon(QMessageBox.Warning)
            error.setStandardButtons(QMessageBox.Ok)
            error.exec_()

    def handler_send(self):
        message = self.line_msg.text()
        self.client.send_message(self.current_chat_user, message)
        self.line_msg.clear()
        self.list_Widget.addItem(f"[{time.strftime('%H:%M:%S')} Me] {message}")

    def thread_recv(self):
        while True:
            self.event.wait()
            if self.client.msg_queue[-1]['sender'] == self.current_chat_user:
                self.list_Widget.addItem(f"[{time.strftime('%H:%M:%S')} {self.client.msg_queue[-1]['sender']}] {self.client.msg_queue[-1]['msg']}")
            else:
                item = self.list_users.findItems(self.client.msg_queue[-1]['sender'],  QtCore.Qt.MatchFlag.MatchExactly)[0]
                item.setForeground(QtGui.QColor('red'))
            self.event.clear()


class client(object):
    MSG_TYPE_REG = 'register'
    MSG_TYPE_AUTH = 'auth'
    MSG_TYPE_MSG = 'msg'
    MSG_TYPE_CONTACTS = 'contacts'
    MSG_TYPE_REQKEY = 'req_key'

    MSG_RESPONSE_OK = 'OK'
    MSG_RESPONSE_FAIL = 'FAIL'

    def __init__(self):
        self.sock = None
        self.connected = False
        self.users_keys = {}
        self.messages = {}

        self.recv_thread = None
        self.recv_queue = queue.Queue()
        self.msg_queue = []

    def __del__(self):
        if self.connected:
            self.disconnect()

    def load_keys(self, client_key_path, srv_key_path):
        try:
            with open(srv_key_path, 'r') as key_file:
                fc = key_file.read()
                self.srv_key = json.loads(fc)['public']
                logging.debug(f'Server key loaded: {self.srv_key=}')
        except:
            logging.error(f"Can't load server key from {srv_key_path}")
            return False

        try:
            with open(client_key_path, "r") as key_file:
                fc = key_file.read()
                j = json.loads(fc)
                self.public_key = j['public']
                self.private_key = j['private']
                logging.debug(f'Keys loaded: {self.public_key=}, {self.private_key=}')
        except FileNotFoundError:
            logging.warning(f"Can't load user keys from {client_key_path}. Generating new keys")
            privKey = generate_eth_key()
            self.private_key = privKey.to_hex()
            self.public_key = privKey.public_key.to_hex()

            with open(client_key_path, 'w') as f:
                f.write(f'{{"public": "{self.public_key}", "private": "{self.private_key}"}}')
            logging.warning(f"User keys successfully generated and stored in {client_key_path}")
        except json.JSONDecodeError:
            logging.error(f"Invalid user keys file format in {client_key_path}")
            return False

    def connect(self, user, password, event, server='localhost', port=9000):
        if self.connected:
            return True

        self.server = server
        self.port = port
        self.user = user
        self.password = password
        self.event = event

        password_hash = hashlib.sha256(self.password.encode()).hexdigest()

        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

        self.sock.connect((self.server, self.port))

        if not self.recv_thread:
            self.recv_thread = threading.Thread(target=self.recv_message, daemon=True)
            self.recv_thread.start()

        msg = f'{{"type": "auth", "user": "{self.user}", "hash": "{password_hash}"}}'.encode()
        msg = encrypt(self.srv_key, msg)
        self.sock.send(msg)

        try:
            response = self.recv_queue.get(timeout=5)
        except:
            self.disconnect()
            return False

        if response.get('type') != self.MSG_TYPE_AUTH or response.get('result') != self.MSG_RESPONSE_OK:
            self.disconnect()
            return False

        self.connected = True
        return True

    def disconnect(self):
        if self.connected:
            self.sock.close()
            self.sock = None
            self.connected = False
            self.users_keys = {}
            self.recv_thread = None

    def register_user(self, user, password, server='localhost', port=9000):
        password_hash = hashlib.sha256(password.encode()).hexdigest()

        sock = socket.socket(socket.AF_INET)
        sock.settimeout(10)
        sock.connect((server, port))

        msg = f'{{"type": "{self.MSG_TYPE_REG}", "user": "{user}", "hash": "{password_hash}", "pub_key": "{self.public_key}"}}'.encode()
        encrypted = encrypt(self.srv_key, msg)
        sock.send(encrypted)

        try:
            response = sock.recv(1024 * 1024)
            response = decrypt(self.private_key, response)
            response = json.loads(response)

        except (TimeoutError, json.JSONDecodeError, UnicodeDecodeError):
            logging.debug("register_user: response has invalid format")
            return False

        except ValueError:
            logging.debug("Can't decrypt response")
            response = json.loads(response)

        if response.get('type') != self.MSG_TYPE_REG or response.get('result') != self.MSG_RESPONSE_OK:
            logging.debug("Server has returned FAIL response")
            return False

        sock.close()
        return True

    def load_users(self):
        msg = f'{{"type": "{self.MSG_TYPE_CONTACTS}"}}'.encode()
        msg = encrypt(self.srv_key, msg)
        self.sock.send(msg)
        try:
            data = self.recv_queue.get(timeout=5)
        except:
            self.users_list = {}
            return False

        contacts_list = data.get('list')
        if data.get('type') != self.MSG_TYPE_CONTACTS or not contacts_list:
            self.users_list = {}
            return False

        self.users_list = contacts_list

    def req_key(self, user):
        msg = json.dumps({'type': self.MSG_TYPE_REQKEY, 'user': user}).encode()
        msg = encrypt(self.srv_key, msg)
        self.sock.send(msg)
        try:
            data = self.recv_queue.get(timeout=5)
        except:
            logging.error('req_key: queue.get error')
            return False

        if data.get('result') == self.MSG_RESPONSE_FAIL or data.get('type') != self.MSG_TYPE_REQKEY:
            logging.error('req_key: response error')
            return False

        self.users_keys[user] = data['pub_key']
        return True

    def send_message(self, user, msg):
        key = self.users_list[user]
        encrypted = encrypt(key, msg.encode())
        encoded = base64.b64encode(encrypted).decode()
        message = json.dumps({'type': self.MSG_TYPE_MSG, 'recipient': user, 'msg': encoded})
        encrypded_msg = encrypt(self.srv_key, message.encode())
        self.sock.send(encrypded_msg)

        if self.messages.get(user):
            self.messages[user].append({'type': self.MSG_TYPE_MSG, 'recipient': user, 'msg': msg, 'time': int(time.time()), 'sender': self.user})
        else:
            self.messages[user] = [{'type': self.MSG_TYPE_MSG, 'recipient': user, 'msg': msg, 'time': int(time.time()), 'sender': self.user}]

    def recv_message(self):
        while True:
            try:
                data = self.sock.recv(1024 * 1024)
                encrypted_message = decrypt(self.private_key, data)
                jdata = json.loads(encrypted_message.decode())
                if jdata.get('msg'):
                    decrypted_msg = decrypt(self.private_key, base64.b64decode(jdata['msg'].encode()))
                    jdata['msg'] = decrypted_msg.decode()

                    if self.messages.get(jdata['sender']):
                        self.messages[jdata['sender']].append(jdata)
                    else:
                        self.messages[jdata['sender']] = [jdata]

                    self.msg_queue.append(jdata)
                    self.event.set()
                else:
                    self.recv_queue.put(jdata)
            except (TimeoutError, json.JSONDecodeError, UnicodeDecodeError, ValueError) as e:
                print(f'An exception was occurred: {e}')
            except OSError:
                break


if __name__ == "__main__":
    import sys

    logging.basicConfig(level=logging.DEBUG, format='[%(asctime)s] %(levelname)s: %(message)s')

    # Take user keyfile name from arguments
    if len(sys.argv) == 2:
        KEY_PATH = sys.argv[1]

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
